<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Passport Photo Creator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Face-api.js for AI face detection -->
    <script defer src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <style>
        /* ...[keep all your original CSS as above]... */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #334155;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        /* [keep the rest of your CSS unchanged for brevity] */
        /* ... */
    </style>
</head>
<body class="flex flex-col min-h-screen">
    <div id="loadingOverlay" class="loading-overlay hidden">
        <div class="spinner"></div>
        <p>Processing...</p>
    </div>

    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button id="messageBoxOk">OK</button>
    </div>
    <div id="overlay" class="overlay"></div>

    <header class="bg-gradient-to-r from-violet-600 to-indigo-600 text-white py-8 text-center rounded-b-xl shadow-lg">
        <h1 class="text-4xl font-bold mb-2">Passport Photo Creator</h1>
        <p class="text-lg">Get ready to make perfect passport photos with ease.</p>
        <p class="mt-4 text-md">— Nishikant Xalxo <a href="https://www.instagram.com/nishix_vamp" target="_blank" class="text-white hover:underline font-medium">@nishix_vamp</a></p>
    </header>

    <main class="container py-8">
        <!-- ...[keep all your original sections unchanged for brevity]... -->
        <section id="photo-upload-section" class="app-section">
            <h2 class="text-2xl mb-4">2. Upload & Crop Your Photo</h2>
            <p class="mb-4 text-gray-600">Upload your photo. The photo will be auto-centered on your face for best results. You can fine-tune the crop frame as needed.</p>
            <input type="file" id="photoUpload" accept="image/*,.png,.jpg,.jpeg,.bmp,.webp,.heic,.heif" class="w-full">

            <div id="cropContainer" class="crop-container hidden">
                <img id="uploadedImage" class="absolute hidden" alt="Uploaded Image">
                <div id="cropArea" class="crop-area">
                    <div class="crop-handle top-left" data-handle="tl"></div>
                    <div class="crop-handle top-right" data-handle="tr"></div>
                    <div class="crop-handle bottom-left" data-handle="bl"></div>
                    <div class="crop-handle bottom-right" data-handle="br"></div>
                </div>
            </div>
            <div class="flex justify-center items-center gap-4 mt-4">
                <button id="zoomOutBtn" class="btn-secondary px-4 py-2 text-xl font-bold">-</button>
                <span class="text-gray-700">Zoom: <span id="zoomLevel">100%</span></span>
                <button id="zoomInBtn" class="btn-secondary px-4 py-2 text-xl font-bold">+</button>
            </div>

            <div class="flex justify-between gap-4 mt-6">
                <button id="backToInitialSetupBtn" class="btn-secondary">Back: Initial Setup</button>
                <button id="nextToConfigurePreviewBtn" class="btn-primary" disabled>Next: Configure & Preview</button>
            </div>
            <!-- AI face detection status -->
            <div id="faceDetectionStatus" class="text-center mt-4 text-sm text-violet-600"></div>
        </section>
        <!-- ...[keep all your original sections unchanged for brevity]... -->
    </main>
    <!-- ...[footer and rest of the HTML remain unchanged]... -->

    <footer class="footer">
        <p class="text-lg mb-2">"Success is not final, failure is not fatal: It is the courage to continue that counts."</p>
        <p class="text-md">— Nishikant Xalxo <a href="https://www.instagram.com/nishix_vamp" target="_blank">@nishix_vamp</a></p>
    </footer>

    <script>
        // --- Utility Functions for Message Box and Loading Overlay ---
        function showMessage(message) {
            document.getElementById('messageText').textContent = message;
            document.getElementById('messageBox').style.display = 'flex';
            document.getElementById('overlay').style.display = 'block';
        }

        function hideMessage() {
            document.getElementById('messageBox').style.display = 'none';
            document.getElementById('overlay').style.display = 'none';
        }

        function showLoading(message = 'Processing...') {
            document.getElementById('loadingOverlay').querySelector('p').textContent = message;
            document.getElementById('loadingOverlay').classList.remove('hidden');
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').classList.add('hidden');
        }

        let faceApiLoaded = false;
        let faceApiLoading = false;
        async function ensureFaceApiLoaded() {
            if (faceApiLoaded) return true;
            if (faceApiLoading) {
                while (!faceApiLoaded) await new Promise(resolve => setTimeout(resolve, 200));
                return true;
            }
            faceApiLoading = true;
            showLoading("Loading AI face detector...");
            document.getElementById('faceDetectionStatus').textContent = 'Loading face detection AI...';
            const MODELS_URL = 'https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/weights';
            try {
                await faceapi.nets.tinyFaceDetector.loadFromUri(MODELS_URL);
                faceApiLoaded = true;
                document.getElementById('faceDetectionStatus').textContent = '';
                hideLoading();
                return true;
            } catch (e) {
                hideLoading();
                document.getElementById('faceDetectionStatus').textContent = 'AI face detection failed to load. You can still crop manually.';
                return false;
            }
        }

        // --- Core Application Logic ---
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const sections = {
                initialSetup: document.getElementById('initial-setup-section'),
                photoUpload: document.getElementById('photo-upload-section'),
                configurePreview: document.getElementById('configure-preview-section'),
                shareApp: document.getElementById('share-app-section')
            };

            const photoUploadInput = document.getElementById('photoUpload');
            const uploadedImage = document.getElementById('uploadedImage');
            const cropContainer = document.getElementById('cropContainer');
            const cropArea = document.getElementById('cropArea');
            const cropHandles = cropArea.querySelectorAll('.crop-handle');
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const zoomLevelSpan = document.getElementById('zoomLevel');
            const faceDetectionStatus = document.getElementById('faceDetectionStatus');

            // Navigation Buttons
            const nextToUploadBtn = document.getElementById('nextToUploadBtn');
            const backToInitialSetupBtn = document.getElementById('backToInitialSetupBtn');
            const nextToConfigurePreviewBtn = document.getElementById('nextToConfigurePreviewBtn');
            const backToPhotoUploadBtn = document.getElementById('backToPhotoUploadBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const backToConfigurePreviewBtn = document.getElementById('backToConfigurePreviewBtn');

            // Initial Setup Controls
            const unitRadios = document.querySelectorAll('input[name="units"]');
            const pageSizeRadios = document.querySelectorAll('input[name="pageSize"]');
            const passportPhotoWidthInput = document.getElementById('passportPhotoWidth');
            const passportPhotoHeightInput = document.getElementById('passportPhotoHeight');
            const photoUnitW = document.getElementById('photoUnitW');
            const photoUnitH = document.getElementById('photoUnitH');

            // Configure & Preview Controls
            const horizontalSpacingInput = document.getElementById('horizontalSpacing');
            const verticalSpacingInput = document.getElementById('verticalSpacing');
            const topMarginInput = document.getElementById('topMargin');
            const bottomMarginInput = document.getElementById('bottomMargin');
            const leftMarginInput = document.getElementById('leftMargin');
            const rightMarginInput = document.getElementById('rightMargin');
            const marginInputs = [topMarginInput, bottomMarginInput, leftMarginInput, rightMarginInput];
            const unitDisplaySpans = {
                H: document.getElementById('unitDisplayH'),
                V: document.getElementById('unitDisplayV'),
                T: document.getElementById('unitDisplayT'),
                B: document.getElementById('unitDisplayB'),
                L: document.getElementById('unitDisplayL'),
                R: document.getElementById('unitDisplayR')
            };
            const numPhotosInput = document.getElementById('numPhotos');
            const maxPhotosSpan = document.getElementById('maxPhotos');
            const finalPreviewCanvas = document.getElementById('finalPreviewCanvas');
            const finalPreviewCtx = finalPreviewCanvas.getContext('2d', { willReadFrequently: true });
            const downloadFormatRadios = document.querySelectorAll('input[name="downloadFormat"]');
            const enableDottedLinesCheckbox = document.getElementById('enableDottedLines');
            const autoMarginCheckbox = document.getElementById('autoMarginCheckbox');

            // Share App Controls
            const shareTwitterBtn = document.getElementById('shareTwitter');
            const shareFacebookBtn = document.getElementById('shareFacebook');
            const copyLinkBtn = document.getElementById('copyLink');

            // --- State Variables ---
            let currentSection = 'initialSetup';
            let originalImage = null;
            let croppedImageDataURL = null;
            let croppedImage = null;

            let isDraggingCropArea = false;
            let isResizingCrop = false;
            let activeHandle = null;
            let startX, startY;
            let cropRect = { x: 0, y: 0, width: 200, height: 260 };
            let passportPhotoAspectRatio = 35 / 45;

            let isDraggingImage = false;
            let imgCurrentX = 0, imgCurrentY = 0;
            let currentZoom = 1.0;
            const ZOOM_STEP = 0.1;
            const MIN_ZOOM = 0.1;
            const MAX_ZOOM = 5.0;

            const DPI = 300;
            const MM_PER_INCH = 25.4;
            const PX_PER_MM = DPI / MM_PER_INCH;
            const PX_PER_INCH = DPI;

            let currentUnit = document.querySelector('input[name="units"]:checked').value;

            // --- Helper Functions ---
            function convertUnits(value, fromUnit, toUnit) {
                if (fromUnit === toUnit) return value;
                let pxValue;
                if (fromUnit === 'px') pxValue = value;
                else if (fromUnit === 'mm') pxValue = value * PX_PER_MM;
                else if (fromUnit === 'in') pxValue = value * PX_PER_INCH;
                else throw new Error('Unknown fromUnit: ' + fromUnit);
                if (toUnit === 'px') return pxValue;
                else if (toUnit === 'mm') return pxValue / PX_PER_MM;
                else if (toUnit === 'in') return pxValue / PX_PER_INCH;
                else throw new Error('Unknown toUnit: ' + toUnit);
            }
            function updateUnitDisplays() {
                const selectedUnit = document.querySelector('input[name="units"]:checked').value;
                photoUnitW.textContent = selectedUnit;
                photoUnitH.textContent = selectedUnit;
                passportPhotoWidthInput.value = convertUnits(parseFloat(passportPhotoWidthInput.value || 0), currentUnit, selectedUnit).toFixed(1);
                passportPhotoHeightInput.value = convertUnits(parseFloat(passportPhotoHeightInput.value || 0), currentUnit, selectedUnit).toFixed(1);
                for (const key in unitDisplaySpans) {
                    unitDisplaySpans[key].textContent = selectedUnit;
                }
                horizontalSpacingInput.value = convertUnits(parseFloat(horizontalSpacingInput.value || 0), currentUnit, selectedUnit).toFixed(1);
                verticalSpacingInput.value = convertUnits(parseFloat(verticalSpacingInput.value || 0), currentUnit, selectedUnit).toFixed(1);
                topMarginInput.value = convertUnits(parseFloat(topMarginInput.value || 0), currentUnit, selectedUnit).toFixed(1);
                bottomMarginInput.value = convertUnits(parseFloat(bottomMarginInput.value || 0), currentUnit, selectedUnit).toFixed(1);
                leftMarginInput.value = convertUnits(parseFloat(leftMarginInput.value || 0), currentUnit, selectedUnit).toFixed(1);
                rightMarginInput.value = convertUnits(parseFloat(rightMarginInput.value || 0), currentUnit, selectedUnit).toFixed(1);
                currentUnit = selectedUnit;
                updatePassportPhotoAspectRatio();
            }
            function updatePassportPhotoAspectRatio() {
                const width = parseFloat(passportPhotoWidthInput.value || 0);
                const height = parseFloat(passportPhotoHeightInput.value || 0);
                if (width > 0 && height > 0) {
                    passportPhotoAspectRatio = width / height;
                } else {
                    passportPhotoAspectRatio = 35 / 45;
                }
            }
            function showSection(sectionId) {
                for (const key in sections) {
                    sections[key].classList.remove('active');
                }
                sections[sectionId].classList.add('active');
                currentSection = sectionId;
                sections[sectionId].scrollIntoView({ behavior: 'smooth', block: 'start' });
                if (sectionId === 'configurePreview') {
                    updateUnitDisplays();
                    updatePreview();
                }
            }
            // --- Initial Setup Event Listeners ---
            unitRadios.forEach(el => {
                el.addEventListener('change', updateUnitDisplays);
            });
            [passportPhotoWidthInput, passportPhotoHeightInput].forEach(el => {
                el.addEventListener('input', () => {
                    updatePassportPhotoAspectRatio();
                    if (currentSection === 'photoUpload' && originalImage) {
                        const containerWidth = cropContainer.offsetWidth;
                        const containerHeight = cropContainer.offsetHeight;
                        let initialCropWidth = Math.min(containerWidth * 0.7, 200);
                        let initialCropHeight = initialCropWidth / passportPhotoAspectRatio;
                        if (initialCropHeight > containerHeight * 0.7) {
                            initialCropHeight = Math.min(containerHeight * 0.7, 260);
                            initialCropWidth = initialCropHeight * passportPhotoAspectRatio;
                        }
                        cropRect.width = initialCropWidth;
                        cropRect.height = initialCropHeight;
                        cropRect.x = (containerWidth - cropRect.width) / 2;
                        cropRect.y = (containerHeight - cropRect.height) / 2;
                        updateCropAreaStyle();
                        constrainImagePosition();
                    }
                    if (currentSection === 'configurePreview') {
                        updatePreview();
                    }
                });
            });
            updateUnitDisplays();

            // --- ADVANCED: AI Face Detection + Universal Uploading ---
            photoUploadInput.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    uploadedImage.classList.add('hidden');
                    cropContainer.classList.add('hidden');
                    nextToConfigurePreviewBtn.disabled = true;
                    originalImage = null;
                    croppedImageDataURL = null;
                    croppedImage = null;
                    faceDetectionStatus.textContent = '';
                    return;
                }
                showLoading('Loading image...');
                nextToConfigurePreviewBtn.disabled = true;
                faceDetectionStatus.textContent = '';
                // Accept all formats (including HEIC/HEIF, BMP, WebP) if browser supports
                let imgUrl;
                try {
                    // Prefer object URLs for large files and to avoid loading into memory
                    imgUrl = URL.createObjectURL(file);
                } catch (e) {
                    // fallback to FileReader
                    const reader = new FileReader();
                    reader.onload = (e) => { imgUrl = e.target.result; };
                    reader.readAsDataURL(file);
                }
                // Prepare image element
                originalImage = new window.Image();
                originalImage.onload = async () => {
                    uploadedImage.src = originalImage.src;
                    uploadedImage.classList.remove('hidden');
                    cropContainer.classList.remove('hidden');
                    nextToConfigurePreviewBtn.disabled = false;
                    // AI Face Detection
                    let faceBox = null;
                    try {
                        if (await ensureFaceApiLoaded()) {
                            showLoading('Detecting face...');
                            faceDetectionStatus.textContent = 'Detecting face...';
                            // Use TinyFaceDetector for speed
                            const detection = await faceapi.detectSingleFace(originalImage, new faceapi.TinyFaceDetectorOptions());
                            if (detection) {
                                faceBox = detection.box;
                                faceDetectionStatus.textContent = 'Face detected!';
                                // Center crop around detected face
                                centerCropOnFace(faceBox, originalImage);
                            } else {
                                faceDetectionStatus.textContent = 'No face detected. Please adjust crop manually.';
                                autoFitCrop(originalImage);
                            }
                        } else {
                            autoFitCrop(originalImage);
                        }
                    } catch (e) {
                        faceDetectionStatus.textContent = 'Face detection failed. Adjust crop manually.';
                        autoFitCrop(originalImage);
                    }
                    hideLoading();
                };
                originalImage.onerror = () => {
                    hideLoading();
                    showMessage('Failed to load image. Please try a different file.');
                    nextToConfigurePreviewBtn.disabled = true;
                    faceDetectionStatus.textContent = '';
                };
                originalImage.src = imgUrl;
            });

            function autoFitCrop(image) {
                // Fit the image such that the crop area is centered and covers as much as possible
                const containerWidth = cropContainer.offsetWidth;
                const containerHeight = cropContainer.offsetHeight;
                let initialCropWidth = Math.min(containerWidth * 0.7, 200);
                let initialCropHeight = initialCropWidth / passportPhotoAspectRatio;
                if (initialCropHeight > containerHeight * 0.7) {
                    initialCropHeight = Math.min(containerHeight * 0.7, 260);
                    initialCropWidth = initialCropHeight * passportPhotoAspectRatio;
                }
                cropRect.width = initialCropWidth;
                cropRect.height = initialCropHeight;
                cropRect.x = (containerWidth - cropRect.width) / 2;
                cropRect.y = (containerHeight - cropRect.height) / 2;
                updateCropAreaStyle();
                // Fit image in crop area
                const scaleX = cropRect.width / image.width;
                const scaleY = cropRect.height / image.height;
                currentZoom = Math.max(scaleX, scaleY);
                // Set scaled image dimensions
                const newImgWidth = image.width * currentZoom;
                const newImgHeight = image.height * currentZoom;
                uploadedImage.style.width = `${newImgWidth}px`;
                uploadedImage.style.height = `${newImgHeight}px`;
                // Center image within crop area
                imgCurrentX = cropRect.x + (cropRect.width / 2) - (newImgWidth / 2);
                imgCurrentY = cropRect.y + (cropRect.height / 2) - (newImgHeight / 2);
                uploadedImage.style.left = `${imgCurrentX}px`;
                uploadedImage.style.top = `${imgCurrentY}px`;
                updateZoomLevelDisplay();
                constrainImagePosition();
            }

            function centerCropOnFace(faceBox, image) {
                // Enlarge the crop area to include some margin around the face
                const containerWidth = cropContainer.offsetWidth;
                const containerHeight = cropContainer.offsetHeight;
                const faceCenterX = faceBox.x + faceBox.width / 2;
                const faceCenterY = faceBox.y + faceBox.height / 2;
                // Crop should cover the face and some margin
                let targetCropHeight = Math.max(faceBox.height * 2, image.height * 0.5, 180);
                let targetCropWidth = targetCropHeight * passportPhotoAspectRatio;
                // Ensure not bigger than image
                if (targetCropWidth > image.width) targetCropWidth = image.width;
                if (targetCropHeight > image.height) targetCropHeight = image.height;
                // Position: center crop around face, within image bounds
                let cropX = faceCenterX - targetCropWidth / 2;
                let cropY = faceCenterY - targetCropHeight / 2;
                if (cropX < 0) cropX = 0;
                if (cropY < 0) cropY = 0;
                if (cropX + targetCropWidth > image.width) cropX = image.width - targetCropWidth;
                if (cropY + targetCropHeight > image.height) cropY = image.height - targetCropHeight;
                // Now, scale to container display
                const cropAreaDisplayWidth = Math.min(targetCropWidth, containerWidth * 0.7);
                const cropAreaDisplayHeight = cropAreaDisplayWidth / passportPhotoAspectRatio;
                cropRect.width = cropAreaDisplayWidth;
                cropRect.height = cropAreaDisplayHeight;
                cropRect.x = (containerWidth - cropRect.width) / 2;
                cropRect.y = (containerHeight - cropRect.height) / 2;
                updateCropAreaStyle();
                // Scale image so that the crop area fits the target face region
                currentZoom = cropAreaDisplayWidth / targetCropWidth;
                // Set scaled image dimensions
                const newImgWidth = image.width * currentZoom;
                const newImgHeight = image.height * currentZoom;
                uploadedImage.style.width = `${newImgWidth}px`;
                uploadedImage.style.height = `${newImgHeight}px`;
                // Position image so that the face is centered in the crop area
                imgCurrentX = cropRect.x - cropX * currentZoom;
                imgCurrentY = cropRect.y - cropY * currentZoom;
                uploadedImage.style.left = `${imgCurrentX}px`;
                uploadedImage.style.top = `${imgCurrentY}px`;
                updateZoomLevelDisplay();
                constrainImagePosition();
            }

            function updateCropAreaStyle() {
                cropArea.style.left = `${cropRect.x}px`;
                cropArea.style.top = `${cropRect.y}px`;
                cropArea.style.width = `${cropRect.width}px`;
                cropArea.style.height = `${cropRect.height}px`;
            }
            function constrainImagePosition() {
                const imgWidth = uploadedImage.offsetWidth;
                const imgHeight = uploadedImage.offsetHeight;
                // If image is smaller than crop area, zoom in to fill
                if (imgWidth < cropRect.width || imgHeight < cropRect.height) {
                    const scaleX = cropRect.width / imgWidth;
                    const scaleY = cropRect.height / imgHeight;
                    const scaleFactor = Math.max(scaleX, scaleY);
                    currentZoom *= scaleFactor;
                    currentZoom = Math.min(currentZoom, MAX_ZOOM);
                    updateZoomLevelDisplay();
                    uploadedImage.style.width = `${originalImage.width * currentZoom}px`;
                    uploadedImage.style.height = `${originalImage.height * currentZoom}px`;
                    const newImgWidth = uploadedImage.offsetWidth;
                    const newImgHeight = uploadedImage.offsetHeight;
                    imgCurrentX = cropRect.x + (cropRect.width / 2) - (newImgWidth / 2);
                    imgCurrentY = cropRect.y + (cropRect.height / 2) - (newImgHeight / 2);
                }
                if (imgCurrentX > cropRect.x) imgCurrentX = cropRect.x;
                if (imgCurrentY > cropRect.y) imgCurrentY = cropRect.y;
                if (imgCurrentX + imgWidth < cropRect.x + cropRect.width) imgCurrentX = (cropRect.x + cropRect.width) - imgWidth;
                if (imgCurrentY + imgHeight < cropRect.y + cropRect.height) imgCurrentY = (cropRect.y + cropRect.height) - imgHeight;
                uploadedImage.style.left = `${imgCurrentX}px`;
                uploadedImage.style.top = `${imgCurrentY}px`;
            }
            // ...[keep the rest of your original drag/zoom/crop code unchanged]...

            let activeElement = null;

            function getCoords(e) {
                if (e.touches && e.touches.length > 0) {
                    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
                return { x: e.clientX, y: e.clientY };
            }
            function startDrag(e) {
                e.preventDefault();
                activeElement = e.target;
                const coords = getCoords(e);
                startX = coords.x;
                startY = coords.y;
                if (activeElement === uploadedImage) {
                    isDraggingImage = true;
                    uploadedImage.style.cursor = 'grabbing';
                } else if (activeElement.classList.contains('crop-handle')) {
                    isResizingCrop = true;
                    activeHandle = activeElement.dataset.handle;
                } else if (activeElement === cropArea) {
                    isDraggingCropArea = true;
                    cropArea.style.cursor = 'grabbing';
                }
            }
            function doDrag(e) {
                if (!activeElement) return;
                e.preventDefault();
                const coords = getCoords(e);
                const dx = coords.x - startX;
                const dy = coords.y - startY;
                if (isDraggingImage) {
                    imgCurrentX += dx;
                    imgCurrentY += dy;
                    constrainImagePosition();
                } else if (isDraggingCropArea) {
                    let newCropX = cropRect.x + dx;
                    let newCropY = cropRect.y + dy;
                    const containerWidth = cropContainer.offsetWidth;
                    const containerHeight = cropContainer.offsetHeight;
                    if (newCropX < 0) newCropX = 0;
                    if (newCropY < 0) newCropY = 0;
                    if (newCropX + cropRect.width > containerWidth) newCropX = containerWidth - cropRect.width;
                    if (newCropY + cropRect.height > containerHeight) newCropY = containerHeight - cropRect.height;
                    cropRect.x = newCropX;
                    cropRect.y = newCropY;
                    updateCropAreaStyle();
                    constrainImagePosition();
                } else if (isResizingCrop) {
                    const minCropSize = 50;
                    const containerRect = cropContainer.getBoundingClientRect();
                    const currentClientX = coords.x;
                    const currentClientY = coords.y;
                    let newX = cropRect.x;
                    let newY = cropRect.y;
                    let newWidth = cropRect.width;
                    let newHeight = cropRect.height;
                    let fixedX, fixedY;
                    if (activeHandle === 'tl') { fixedX = cropRect.x + cropRect.width; fixedY = cropRect.y + cropRect.height; }
                    else if (activeHandle === 'tr') { fixedX = cropRect.x; fixedY = cropRect.y + cropRect.height; }
                    else if (activeHandle === 'bl') { fixedX = cropRect.x + cropRect.width; fixedY = cropRect.y; }
                    else if (activeHandle === 'br') { fixedX = cropRect.x; fixedY = cropRect.y; }
                    let tempWidth = Math.abs(currentClientX - containerRect.left - fixedX);
                    let tempHeight = Math.abs(currentClientY - containerRect.top - fixedY);
                    if (passportPhotoAspectRatio > 0) {
                        if (tempWidth / passportPhotoAspectRatio > tempHeight) {
                            tempHeight = tempWidth / passportPhotoAspectRatio;
                        } else {
                            tempWidth = tempHeight * passportPhotoAspectRatio;
                        }
                    } else {
                        tempWidth = Math.max(tempWidth, minCropSize);
                        tempHeight = Math.max(tempHeight, minCropSize);
                    }
                    if (tempWidth < minCropSize) {
                        tempWidth = minCropSize;
                        tempHeight = minCropSize / passportPhotoAspectRatio;
                    }
                    if (tempHeight < minCropSize) {
                        tempHeight = minCropSize;
                        tempWidth = minCropSize * passportPhotoAspectRatio;
                    }
                    switch (activeHandle) {
                        case 'tl':
                            newX = fixedX - tempWidth;
                            newY = fixedY - tempHeight;
                            break;
                        case 'tr':
                            newX = fixedX;
                            newY = fixedY - tempHeight;
                            break;
                        case 'bl':
                            newX = fixedX - tempWidth;
                            newY = fixedY;
                            break;
                        case 'br':
                            newX = fixedX;
                            newY = fixedY;
                            break;
                    }
                    cropRect.x = newX;
                    cropRect.y = newY;
                    cropRect.width = tempWidth;
                    cropRect.height = tempHeight;
                    const containerWidth = cropContainer.offsetWidth;
                    const containerHeight = cropContainer.offsetHeight;
                    cropRect.x = Math.max(0, Math.min(cropRect.x, containerWidth - cropRect.width));
                    cropRect.y = Math.max(0, Math.min(cropRect.y, containerHeight - cropRect.height));
                    cropRect.width = Math.min(cropRect.width, containerWidth - cropRect.x);
                    cropRect.height = Math.min(cropRect.height, containerHeight - cropRect.y);
                    updateCropAreaStyle();
                    constrainImagePosition();
                }
                startX = coords.x;
                startY = coords.y;
            }
            function endDrag() {
                if (isDraggingImage) {
                    uploadedImage.style.cursor = 'grab';
                }
                if (isDraggingCropArea) {
                    cropArea.style.cursor = 'grab';
                }
                isDraggingImage = false;
                isResizingCrop = false;
                isDraggingCropArea = false;
                activeElement = null;
                activeHandle = null;
            }
            uploadedImage.addEventListener('mousedown', startDrag);
            uploadedImage.addEventListener('touchstart', startDrag);
            cropArea.addEventListener('mousedown', startDrag);
            cropArea.addEventListener('touchstart', startDrag);
            cropHandles.forEach(handle => {
                handle.addEventListener('mousedown', startDrag);
                handle.addEventListener('touchstart', startDrag);
            });
            document.addEventListener('mousemove', doDrag);
            document.addEventListener('touchmove', doDrag, { passive: false });
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);

            function updateZoomLevelDisplay() {
                zoomLevelSpan.textContent = `${Math.round(currentZoom * 100)}%`;
            }
            function applyZoom(delta) {
                if (!originalImage) return;
                const oldZoom = currentZoom;
                currentZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, currentZoom + delta));
                if (oldZoom === currentZoom) return;
                const newImgWidth = originalImage.width * currentZoom;
                const newImgHeight = originalImage.height * currentZoom;
                const cropAreaCenterX = cropRect.x + cropRect.width / 2;
                const cropAreaCenterY = cropRect.y + cropRect.height / 2;
                const oldImgCenterX = imgCurrentX + uploadedImage.offsetWidth / 2;
                const oldImgCenterY = imgCurrentY + uploadedImage.offsetHeight / 2;
                const relativeX = (oldImgCenterX - cropAreaCenterX) / uploadedImage.offsetWidth;
                const relativeY = (oldImgCenterY - cropAreaCenterY) / uploadedImage.offsetHeight;
                imgCurrentX = cropAreaCenterX + (relativeX * newImgWidth) - (newImgWidth / 2);
                imgCurrentY = cropAreaCenterY + (relativeY * newImgHeight) - (newImgHeight / 2);
                uploadedImage.style.width = `${newImgWidth}px`;
                uploadedImage.style.height = `${newImgHeight}px`;
                constrainImagePosition();
                updateZoomLevelDisplay();
            }
            zoomInBtn.addEventListener('click', () => applyZoom(ZOOM_STEP));
            zoomOutBtn.addEventListener('click', () => applyZoom(-ZOOM_STEP));

            // ...[keep your performCrop, updatePreview, download, navigation, share, etc. logic unchanged]...

            // The rest of your script remains unchanged, just as in your original.

            // --- Download Logic, Navigation, Share, etc. ---
            // ...[keep your original code as is]...

            document.getElementById('messageBoxOk').addEventListener('click', hideMessage);
        });
    </script>
</body>
</html>
